1.1 Мета роботи

	Розробити програмне забезпечення для  IoT або SmartDevice пристрою, реалізованого на базі будь-якої поширеної на  сьогодні платформи, придатної для реалізації вбудованих систем (Embedded  System). 

1.2 Хід роботи

1)	Опис рішення;
Система використовує мікроконтролер Arduino Uno для зчитування даних з акселерометра та гіроскопа і відображення їх на OLED дисплеї. Основною метою рішення є вимірювання кутових орієнтаційних кутів (roll, pitch, yaw) у реальному часі.
Апаратна частина складається з наступних компонентів:
1.	 Arduino Uno: Мікроконтролер, який керує виконанням програми.
2.	SSD1306 OLED дисплей: Використовується для відображення кутових орієнтаційних кутів на екрані.
3.	MPU6050: Датчик, який містить в собі як акселерометр, так і гіроскоп для вимірювання рухів та орієнтації.
4.	Інтерфейс зв'язку I2C: Використовується для зчитування даних з MPU6050 та відображення їх на OLED дисплеї.
Програмна частина складається з таких компонентів:
1.	Arduino Sketch: Програмний код, який виконується на мікроконтролері Arduino Uno. Цей код зчитує дані з акселерометра та гіроскопа, обчислює кутові орієнтаційні кути та відображає їх на OLED дисплеї.
Під час виконання програми, Arduino Uno зчитує дані з акселерометра та гіроскопа через інтерфейс зв'язку I2C. Після цього він обчислює кутові орієнтаційні кути (roll, pitch, yaw) на основі отриманих даних. Оновлені значення кутів відображаються на OLED дисплеї.
Рисунок 1 – Схема IoT пристрою

2)	Діаграма прецедентів;
На рисунку 2 зображена діаграма прецедентів. 
 
Рисунок 2 – Діаграма прецедентів.

3)	Діаграма взаємодії;
На рисунку 3 зображена діаграма взаємодії.
 
Рисунок 3 – Діаграма взаємодії.

1.	Плата Arduino - Сенсор MPU6050 (Комунікація по шині I2C):
Плата Arduino взаємодіє з сенсором MPU6050 за допомогою протоколу I2C (Inter-Integrated Circuit).
Ця комунікація включає надсилання команд до MPU6050 для запиту даних та отримання відповідей.
Команди включають вказівку регістрів, з яких потрібно зчитати дані.
2.	Плата Arduino - Дисплей OLED SSD1306 (Комунікація по шині I2C):
Плата Arduino взаємодіє з дисплеєм OLED SSD1306 за допомогою протоколу I2C.
Подібно до взаємодії з MPU6050, це включає надсилання команд на дисплей OLED для оновлення вмісту.
3.	Сенсор MPU6050 - Дисплей OLED SSD1306:
Немає прямої комунікації між сенсором MPU6050 та дисплеєм OLED SSD1306.
Сенсор MPU6050 надає дані платі Arduino, яка в свою чергу обробляє ці дані та оновлює відповідно вміст дисплею OLED.
4.	Взаємодія Користувача з Системою:
Ця взаємодія представляє потенційні взаємодії між користувачем та системою.
5.	Основний Цикл: Зчитування Даних Сенсора та Оновлення Дисплею:
Це центральний процес системи, який виконується безперервно в основному циклі Arduino.
Він включає такі кроки:
Зчитування даних сенсора з сенсора MPU6050.
Обробка даних сенсора для розрахунку кутів крену, тангажу та риштування.
Оновлення вмісту, відображеного на дисплеї OLED SSD1306, з розрахованими кутами.
Цей цикл виконується ітеративно, забезпечуючи безперервне оновлення дисплею останніми даними сенсора.

4)	Діаграма діяльності;

На рисунку 4 зображена діаграма діяльності.
 Рисунок 4 – Діаграма діяльності.

1.	Вибір спорту: 
	Користувач обирає конкретний спорт, такий як катання на велосипеді, гольф, фітнес або інші підтримувані види діяльності. Цей вибір налаштовує пристрій для обраного застосунку, налаштовуючи параметри сенсорів та відображення відповідно до вимог застосунку.
2.	Ініціалізація апаратури: 
Після вибору спорту IoT-пристрій ініціалізує свої апаратні компоненти. Це включає активацію сенсорів (акселерометр, гіроскоп).
3.	Зчитування Даних Сенсорів: 
IoT-пристрій постійно зчитує дані сенсорів. Наприклад, в сценарії катання на велосипеді можуть бути зібрані дані, такі як положення голови, нахил та обертання від сенсорів, вбудованих у шолом.
4.	Обробка Даних Сенсорів та Розрахунок Метрик: 
Пристрій обробляє сирі дані сенсорів, щоб отримати значущі метрики, що є специфічними для обраного спортивного застосунку.
5.	Відображення Даних: 
На основі розрахованих метрик IoT-пристрій надає зворотній зв'язок користувачеві або відображає відповідні дані на своєму інтерфейсі. Наприклад, у спортивному застосунку для катання на велосипеді може бути надано попередження про небезпечні положення голови, тоді як у застосунку для гольфу можуть бути відображені дані аналізу удару для допомоги гольфісту в удосконаленні їх техніки.
6.	Завершення Діяльності: 
У цьому етапі IoT-пристрій завершує свою роботу.

5)	Діаграма пакетів.

На рисунку 5 зображена діаграма пакетів. На ній зображені три пакети: 
1.	Arduino Uno Platform Package:
1.1	 SSD1306 Display: Включає класи та функції, пов'язані з використанням OLED дисплея SSD1306.
1.2	 MPU6050 Sensor: Містить класи та функції для взаємодії з датчиком MPU6050, включаючи зчитування даних з акселерометра та гіроскопа.
1.3	 Wire Communication: Містить функції для ініціалізації та взаємодії через I2C шину з іншими пристроями.
1.4	 Serial Communication: Включає функції для виводу даних через UART з мікроконтролера.
2.	User Interface Package:
2.1	 Display: Включає інтерфейси та класи, пов'язані з відображенням даних на OLED дисплеї.
2.2	 Serial Console: Містить класи та функції для відображення інформації на послідовному порту для відладки та взаємодії з користувачем.
3.	Data Package:
3.1	 Data Acquisition Package: Включає класи та функції для збору даних
з датчиків та інших джерел.
3.2	 Data Processing Package: Містить класи та функції для обробки даних,
включаючи обчислення кутових орієнтаційних кутів та інші операції.

Рисунок 5 – Діаграма пакетів.

1.3 Висновки
Під час виконання лабораторної роботи я розробив програмне забезпечення для  IoT або SmartDevice пристрою, реалізованого на платформі Arduino. 

1.4 Посилання на файли
1.	Посилання на відео захисту: 
https://youtu.be/Wzj5dkSeHdY

ДОДАТОК А
Програмний код

1. #include <Wire.h>
2. #include <Adafruit_GFX.h>
3. #include <Adafruit_SSD1306.h>
4. 
5. #define SCREEN_WIDTH 128 // Ширина дисплея OLED (в пікселях)
6. #define SCREEN_HEIGHT 64 // Висота дисплея OLED (в пікселях)
7. 
8. // Оголошення дисплея SSD1306, підключеного до I2C (піни SDA, SCL)
9. Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
10. 
11. const int MPU_ADDRESS = 0x68; // Адреса MPU6050 по I2C
12. float AccX, AccY, AccZ;
13. float GyroX, GyroY, GyroZ;
14. float accAngleX, accAngleY, gyroAngleX, gyroAngleY, gyroAngleZ;
15. float roll, pitch, yaw;
16. float elapsedTime, currentTime, previousTime;
17. 
18. void setup() {
19.   Wire.begin();                      // Ініціалізація зв'язку
20.   Wire.beginTransmission(MPU_ADDRESS);       // Початок зв'язку з MPU6050
21.   Wire.write(0x6B);                  // Розмова з регістром 6B
22.   Wire.write(0x00);                  // Скидання - записуємо 0 в регістр 6B
23.   Wire.endTransmission(true);        // Завершення передачі
24.   delay(20);
25. 
26.   // SSD1306_SWITCHCAPVCC = генерування напруги дисплея з 3.3V внутрішньо
27.   if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
28.     for(;;);
29.   }
30.   display.display();
31.   delay(2000);
32.   display.clearDisplay();
33.   display.setTextSize(1);      // Звичайний масштаб 1:1 пікселів
34.   display.setTextColor(SSD1306_WHITE); // Білий колір тексту
35.   display.setCursor(0, 0);     // Початок в лівому верхньому куті
36. }
37. 
38. void loop() {
39.   // Зчитування даних з акселерометра
40.   Wire.beginTransmission(MPU_ADDRESS);
41.   Wire.write(0x3B); // Починаємо з регістра 0x3B (ACCEL_XOUT_H)
42.   Wire.endTransmission(false);
43.   Wire.requestFrom(MPU_ADDRESS, 6, true); // Зчитуємо 6 регістрів, значення кожної вісі зберігається в 2 регістрах
44. 
45.   AccX = (Wire.read() << 8 | Wire.read()) / 16384.0; // Значення по осі X
46.   AccY = (Wire.read() << 8 | Wire.read()) / 16384.0; // Значення по осі Y
47.   AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0; // Значення по осі Z
48. 
49.   // Обчислення кутів нахилу за допомогою акселерометра
50.   accAngleX = (atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI); 
51.   accAngleY = (atan(-1 * AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI); 
52. 
53.   // Зберігання попереднього часу перед зчитуванням поточного
54.   previousTime = currentTime;
55.   currentTime = millis(); // Зчитування поточного часу
56.   elapsedTime = (currentTime - previousTime) / 1000; // Перетворення мілісекунд в секунди
57. 
58.   // Зчитування даних з гіроскопа
59.   Wire.beginTransmission(MPU_ADDRESS);
60.   Wire.write(0x43); // Початок даних з гіроскопа - адреса першого регістра 0x43
61.   Wire.endTransmission(false);
62.   Wire.requestFrom(MPU_ADDRESS, 6, true); // Зчитуємо 6 регістрів, значення кожної вісі зберігається в 2 регістрах
63. 
64.   GyroX = (Wire.read() << 8 | Wire.read()) / 131.0; // Значення гіроскопа по осі X
65.   GyroY = (Wire.read() << 8 | Wire.read()) / 131.0; // Значення гіроскопа по осі Y
66.   GyroZ = (Wire.read() << 8 | Wire.read()) / 131.0; // Значення гіроскопа по осі Z
67. 
68.   // Оновлення кутів нахилу за допомогою гіроскопа
69.   gyroAngleX = gyroAngleX + GyroX * elapsedTime; // deg/s * s = deg
70.   gyroAngleY = gyroAngleY + GyroY * elapsedTime;
71.   yaw =  yaw + GyroZ * elapsedTime;
72. 
73.   // Об'єднання даних акселерометра та гіроскопа для отримання кінцевих значень кутів нахилу
74.   // Значення кутів нахилу обчислюються, приділяючи 96% ваги значенням гіроскопа та 4% - значенням акселерометра
75.   roll = 0.96 * gyroAngleX + 0.04 * accAngleX; // Кут нахилу в плоскості X
76.   pitch = 0.96 * gyroAngleY + 0.04 * accAngleY; // Кут нахилу в плоскості Y
77. 
78.   // Відображення значень на OLED дисплеї
79.   display.clearDisplay();
80. 
81.   display.setCursor(0, 0);
82.   display.print("Roll: ");
83.   display.print(roll);
84. 
85.   display.setCursor(0, 10);
86.   display.print("Pitch: ");
87.   display.print(pitch);
88. 
89.   display.setCursor(0, 20);
90.   display.print("Yaw: ");
91.   display.print(yaw);
92. 
93.   display.display();
94. 
95.   delay(100);
96. }
97.
